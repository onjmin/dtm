<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="https://avatars.githubusercontent.com/u/88383494" />
    <title>DTM Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/@kazuprog/mml-player@1.0.0/dist/mml-player.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css" />

    <script type="module">
        import * as mdi from 'https://cdn.jsdelivr.net/npm/@mdi/js@7.4.47/mdi.js';

        const DTM = await import(
            location.hostname === 'localhost' ?
                'http://localhost:40298/dist/index.mjs' :
                'https://onjmin.github.io/dtm/demo/index.mjs');

        const renderConfig = {
            bars: 8,
            stepsPerBar: 16,
            keyCount: 49, // C1〜C5
            pitchRangeStart: 0,
            keyHeight: 15,
            stepWidth: 10,
        };

        const hexToRgb = (hex) =>
            [0, 1, 2].map(i => parseInt(hex.slice(1 + i * 2, 3 + i * 2), 16))
        const tracks = [
            { id: 'melody', name: 'メロディー', color: hexToRgb('#3B82F6'), instrument: 0, core: null, volume: 80, mml: '' },
            { id: 'bass', name: 'ベース', color: hexToRgb('#10B981'), instrument: 1, core: null, volume: 70, mml: '' },
            { id: 'chord', name: '伴奏', color: hexToRgb('#F59E0B'), instrument: 2, core: null, volume: 60, mml: '' },
        ];
        let activeTrackId = 'melody';
        let isPlaying = false;
        let noteLengthSteps = 1; // 16分音符
        let mmlPlayer = null;

        let currentOffsetX = 0;
        let currentOffsetY = 0;
        const scrollAmount = 16 * renderConfig.stepWidth; // 例: 1小節分を移動量とする
        let noteLengthSelectEl = null;

        // ----------------------------------------------------------------------
        // NOTE: このデモは「常に最新の動作確認」を行うための最重要入口。
        // 以降の変更でもここを更新して、実装とデモが乖離しないようにすること。
        // ----------------------------------------------------------------------

        const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

        const getMaxOffsetY = () => {
            const gridCanvas = DTM.getGridCanvas();
            return Math.max(0, renderConfig.keyCount * renderConfig.keyHeight - gridCanvas.height);
        };

        const ensureNoteLengthOption = (value) => {
            if (!noteLengthSelectEl) return;
            const normalized = String(value);
            if (!noteLengthSelectEl.querySelector(`option[value="${normalized}"]`)) {
                const option = document.createElement('option');
                option.value = normalized;
                option.textContent = `${value}ステップ`;
                noteLengthSelectEl.appendChild(option);
            }
            noteLengthSelectEl.value = normalized;
        };

        const playPreviewNote = (pitch, durationSteps) => {
            const activeTrack = tracks.find(t => t.id === activeTrackId);
            if (!activeTrack || !mmlPlayer) return;

            const baseLength = 16;
            const noteLength = 1;
            const octave = Math.floor(pitch / 12) + 1;
            const noteName = DTM.PITCH_MAP[pitch % 12];
            const volume = Math.floor((activeTrack.volume * 127) / 100);
            const previewMml = `t120 l${baseLength} v${volume} @${activeTrack.instrument} o${octave}${noteName}${noteLength}`;
            mmlPlayer.play(previewMml);
        };

        window.movePianoRoll = (direction) => {
            const { keyHeight } = renderConfig;
            const maxOffsetY = getMaxOffsetY();

            switch (direction) {
                case 'right':
                    currentOffsetX += scrollAmount;
                    break;
                case 'left':
                    currentOffsetX = Math.max(0, currentOffsetX - scrollAmount);
                    break;
                case 'up':
                    currentOffsetY = clamp(currentOffsetY - keyHeight, 0, maxOffsetY);
                    break;
                case 'down':
                    currentOffsetY = clamp(currentOffsetY + keyHeight, 0, maxOffsetY);
                    break;
            }

            DTM.setDrawOffset(currentOffsetX, currentOffsetY);

            // 再描画
            redrawAll();
        };

        // 全トラックを再描画するメインの関数
        const redrawAll = () => {
            DTM.drawGrid();

            tracks.forEach((track, i) => {
                if (!track.core) return;
                const [r, g, b] = track.color;
                const a = track.id === activeTrackId
                    ? 1
                    : 0.3;
                DTM.drawNotes(
                    track.core.getNotes(),
                    `rgba(${r},${g},${b},${a})`
                );
            });
        };

        // MML出力エリア更新 (既存ロジックをトップレベルに移動)
        const updateMMLOutput = () => {
            const fullMML = `t120 l16 ${tracks.map((t, i) => `@${i} ${t.mml}`).join(';')}`;
            document.getElementById('mml-output').textContent = fullMML;
            document.getElementById('mml-output-status').textContent =
                `(${tracks.length}トラック) MML文字数: ${fullMML.length}`;
        };

        // UIコントロール更新 (既存ロジックをトップレベルに移動)
        const updateControls = () => {
            // 再生ボタン
            const playButton = document.getElementById('play-button');
            playButton.className = `px-4 py-2 rounded-lg font-semibold transition-colors flex items-center space-x-2 ${isPlaying ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}`;
            playButton.innerHTML = isPlaying
                ? `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="${mdi.mdiStop}"></path></svg><span>停止</span>`
                : `<svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="${mdi.mdiPlay}"></path></svg><span>試聴</span>`;

            const trackTabs = document.getElementById('track-tabs');
            const trackContent = document.getElementById('track-content');

            trackTabs.innerHTML = '';
            trackContent.innerHTML = '';

            tracks.forEach(t => {
                // タブ
                const isActive = t.id === activeTrackId;
                const tabClass = `px-4 py-2 text-sm font-medium transition-colors cursor-pointer rounded-t-lg ${isActive ? 'bg-white border-x border-t border-gray-200 text-purple-600 -mb-px' : 'bg-gray-100 hover:bg-gray-200 text-gray-700 border-b border-gray-200'}`;
                trackTabs.innerHTML += `<button onclick="switchTrack('${t.id}')" class="${tabClass}">${t.name}</button>`;

                // コンテンツ
                if (isActive) {
                    trackContent.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <label class="flex items-center space-x-3 w-64 text-sm text-gray-700">
                            <span class="font-medium">音量:</span>
                            <span id="volume-label-${t.id}" class="w-8 text-right font-mono">${t.volume}</span>
                            <input
                                type="range"
                                min="0"
                                max="100"
                                step="1"
                                value="${t.volume}"
                                oninput="handleVolumeChange('${t.id}', this.value)"
                                class="flex-1 h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer accent-purple-500"
                            />
                        </label>
                        <span class="text-sm text-gray-500">音色: @${t.instrument}</span>
                    </div>
                `;
                }
            });
        };

        // 初期化処理を実行
        const initializeDemo = () => {
            const pianoRollContainer = document.getElementById('piano-roll-container');
            const mmlOutput = document.getElementById('mml-output');
            noteLengthSelectEl = document.getElementById('note-length-select');

            // 0. MMLPlayer 初期化
            if (typeof window.MMLPlayer === 'undefined') {
                console.error("mml-player.jsが読み込まれていません。");
                return;
            }
            mmlPlayer = new window.MMLPlayer();

            // 2. Core/Renderer の初期化
            const pianoRollConfig = {
                bars: 8,
                stepsPerBar: 16,
                keyCount: 49, // C1〜C5
                pitchRangeStart: 0,
                keyHeight: 15,
                stepWidth: 10,
            };

            // 1. モジュールに Canvas の初期化を依頼 (DOM操作とイベントリスナーの抽象化)
            // #piano-roll-container の現在のCSSサイズを渡す: w-[800px] h-[450px]
            DTM.init(
                pianoRollContainer.querySelector('#wrapper'),
                800,
                450,
                renderConfig,
            );

            tracks.forEach(track => {
                track.core = new DTM.MMLCore({
                    onMMLGenerated: (mml) => {
                        track.mml = mml;
                        updateMMLOutput();
                    },
                    onNotesChanged: (notes) => {
                        redrawAll();
                    },
                });

                track.core.setVolume(track.volume);
            });

            // 3. イベントリスナーの設定 (ドラッグ/リサイズ/スクロールもここで)
            // NOTE: デモで必ず動作確認するため、UI操作はここに集約すること。
            const gridCanvas = DTM.getGridCanvas();
            const resizeHandleWidth = 6;
            let suppressClick = false;
            let hasDragged = false;
            let dragState = null;

            const findActiveNoteAtPosition = (x, y) => {
                const activeTrack = tracks.find(t => t.id === activeTrackId);
                if (!activeTrack) return null;

                const { stepWidth, keyHeight, keyCount, pitchRangeStart } = renderConfig;
                const offset = DTM.getDrawOffset();

                for (const note of activeTrack.core.getNotes()) {
                    const logicalX = note.startStep * stepWidth;
                    const yIndex = keyCount - 1 - (note.pitch - pitchRangeStart);
                    const logicalY = yIndex * keyHeight;
                    const w = note.durationSteps * stepWidth;
                    const h = keyHeight;
                    const renderX = logicalX - offset.x;
                    const renderY = logicalY - offset.y;

                    if (x >= renderX && x <= renderX + w && y >= renderY && y <= renderY + h) {
                        return note;
                    }
                }

                return null;
            };

            const handlePointerMove = (event) => {
                if (!dragState) return;
                hasDragged = true;

                const { step, pitch } = DTM.getGridPosition(event);
                const activeTrack = tracks.find(t => t.id === activeTrackId);
                if (!activeTrack) return;

                if (dragState.mode === 'move') {
                    const nextStart = step - dragState.dragOffsetStep;
                    const nextPitch = pitch - dragState.dragOffsetPitch;
                    activeTrack.core.moveNote(dragState.noteId, nextStart, nextPitch);
                    if (nextPitch !== dragState.lastPreviewPitch) {
                        dragState.lastPreviewPitch = nextPitch;
                        playPreviewNote(nextPitch, dragState.durationSteps);
                    }
                    return;
                }

                const nextDuration = step - dragState.startStep + 1;
                activeTrack.core.resizeNote(dragState.noteId, nextDuration);
                noteLengthSteps = Math.max(1, nextDuration);
                ensureNoteLengthOption(noteLengthSteps);
            };

            const endDrag = () => {
                if (dragState) {
                    dragState = null;
                    if (hasDragged) {
                        suppressClick = true;
                    }
                }
                hasDragged = false;
            };

            gridCanvas.addEventListener('mousedown', (event) => {
                const { x, y, step, pitch } = DTM.getGridPosition(event);
                const note = findActiveNoteAtPosition(x, y);
                if (!note) return;

                const { stepWidth, keyHeight, keyCount, pitchRangeStart } = renderConfig;
                const offset = DTM.getDrawOffset();
                const logicalX = note.startStep * stepWidth;
                const yIndex = keyCount - 1 - (note.pitch - pitchRangeStart);
                const logicalY = yIndex * keyHeight;
                const renderX = logicalX - offset.x;
                const renderY = logicalY - offset.y;
                const w = note.durationSteps * stepWidth;

                if (
                    x >= renderX + w - resizeHandleWidth &&
                    x <= renderX + w &&
                    y >= renderY &&
                    y <= renderY + keyHeight
                ) {
                    dragState = {
                        noteId: note.id,
                        mode: 'resize',
                        dragOffsetStep: 0,
                        dragOffsetPitch: 0,
                        startStep: note.startStep,
                        durationSteps: note.durationSteps,
                        lastPreviewPitch: note.pitch,
                    };
                    return;
                }

                dragState = {
                    noteId: note.id,
                    mode: 'move',
                    dragOffsetStep: step - note.startStep,
                    dragOffsetPitch: pitch - note.pitch,
                    startStep: note.startStep,
                    durationSteps: note.durationSteps,
                    lastPreviewPitch: note.pitch,
                };
            });

            gridCanvas.addEventListener('mouseleave', endDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('mousemove', handlePointerMove);

            gridCanvas.addEventListener('wheel', (event) => {
                event.preventDefault();
                const maxOffsetY = getMaxOffsetY();
                currentOffsetY = clamp(currentOffsetY + event.deltaY, 0, maxOffsetY);
                DTM.setDrawOffset(currentOffsetX, currentOffsetY);
                redrawAll();
            }, { passive: false });

            // クリックイベントをモジュールに登録
            DTM.onClick((step, pitch) => {
                if (suppressClick) {
                    suppressClick = false;
                    return;
                }

                const activeTrack = tracks.find(t => t.id === activeTrackId);
                if (!activeTrack) return;
                const existingNote = activeTrack.core
                    .getNotes()
                    .some(note => note.startStep === step && note.pitch === pitch);
                activeTrack.core.toggleNote(step, pitch, {
                    noteLengthSteps: noteLengthSteps,
                });
                if (!existingNote) {
                    playPreviewNote(pitch, noteLengthSteps);
                }
            });


            // 4. 初期描画
            updateControls();
            updateMMLOutput();
            redrawAll(); // 初回グリッド描画とノート描画 (ノートは空)

            document.getElementById('play-button').disabled = false;
        };

        // モジュールロード完了後に初期化を実行
        initializeDemo();

        // --- グローバル関数 (UIからの呼び出し用) ---

        window.switchTrack = (id) => {
            activeTrackId = id;
            updateControls();
            redrawAll();
        };

        window.handleVolumeChange = (id, value) => {
            const track = tracks.find(t => t.id === id);
            if (track) {
                track.volume = parseInt(value);
                track.core.setVolume(track.volume);
                document.getElementById(`volume-label-${id}`).textContent = track.volume;
                // ボリュームはMMLに反映される
            }
        };

        window.togglePlayback = () => {
            if (isPlaying) {
                mmlPlayer.stop();
                isPlaying = false;
            } else {
                const fullMML = tracks.map(t => t.mml).join(';');
                mmlPlayer.play(fullMML);
                isPlaying = true;
            }
            updateControls();
        };

        const noteLengthSelect = document.getElementById('note-length-select');
        noteLengthSelect.addEventListener('change', (e) => {
            noteLengthSteps = parseInt(e.target.value);
            // Note: すべてのトラックのRendererに設定する必要がなくなったため、状態変数のみ更新
        });
    </script>
</head>

<body class="bg-gray-100 p-4 min-h-screen">
    <h1 class="text-3xl font-extrabold mb-4 text-gray-800">簡易DAW（Canvas/MML）デモ</h1>

    <div class="flex flex-wrap gap-4 p-4 bg-white border rounded-lg shadow-md mb-6">

        <button id="play-button" onclick="togglePlayback()" disabled class="px-4 py-2 bg-gray-300 rounded"></button>

        <div class="flex items-center space-x-2">
            <span class="text-sm font-medium text-gray-700">ノート長:</span>
            <select id="note-length-select"
                class="border rounded-md px-2 py-1 text-sm focus:ring-blue-500 focus:border-blue-500">
                <option value="4">4分</option>
                <option value="2">8分</option>
                <option value="1" selected>16分</option>
            </select>
        </div>

        <div class="flex items-center space-x-2 border-l border-gray-200 pl-4">
            <span class="text-sm font-medium text-gray-700">ドラム (Track 4):</span>
            <select id="drum-select"
                class="border rounded-md px-2 py-1 text-sm focus:ring-blue-500 focus:border-blue-500">
                <option>なし</option>
                <option>4つ打ち</option>
                <option>ロック</option>
            </select>
            <span class="text-xs text-gray-500">(MML再生には含まず)</span>
        </div>
    </div>

    <div class="p-4 bg-white border rounded-lg shadow-md mb-6">
        <h2 class="text-xl font-semibold text-gray-800 mb-4">トラック設定</h2>

        <div id="track-tabs" class="flex border-b border-gray-200">
        </div>

        <div id="track-content" class="p-4 border border-t-0 border-gray-200 rounded-b-lg bg-white">
        </div>
    </div>


    <div class="flex justify-center space-x-4 mb-2">
        <div class="flex space-x-1">
            <button onclick="movePianoRoll('left')"
                class="p-2 bg-gray-300 hover:bg-gray-400 rounded-lg transition-colors">
                <i class="mdi mdi-chevron-left text-xl"></i>
            </button>
            <button onclick="movePianoRoll('right')"
                class="p-2 bg-gray-300 hover:bg-gray-400 rounded-lg transition-colors">
                <i class="mdi mdi-chevron-right text-xl"></i>
            </button>
            <span class="text-sm self-center text-gray-600 ml-2">水平移動 (1小節)</span>
        </div>

        <div class="flex space-x-1 border-l border-gray-300 pl-4">
            <button onclick="movePianoRoll('up')"
                class="p-2 bg-gray-300 hover:bg-gray-400 rounded-lg transition-colors">
                <i class="mdi mdi-chevron-up text-xl"></i>
            </button>
            <button onclick="movePianoRoll('down')"
                class="p-2 bg-gray-300 hover:bg-gray-400 rounded-lg transition-colors">
                <i class="mdi mdi-chevron-down text-xl"></i>
            </button>
            <span class="text-sm self-center text-gray-600 ml-2">垂直移動 (1キー)</span>
        </div>
    </div>


    <div id="piano-roll-container"
        class="w-[800px] h-[450px] bg-white border border-gray-300 rounded-lg shadow-xl relative"
        style="overflow: hidden;">
        <div id="wrapper" class="absolute inset-0">
        </div>
    </div>

    <hr class="my-6 border-gray-300">

    <div class="p-4 bg-gray-800 text-white rounded-lg shadow-lg">
        <h2 class="text-xl font-semibold mb-2">生成された MML</h2>
        <p id="mml-output-status" class="text-xs mb-2 text-gray-400"></p>
        <pre class="bg-black p-3 rounded-md overflow-x-auto text-sm">
            <code id="mml-output"></code>
        </pre>
    </div>
</body>

</html>
